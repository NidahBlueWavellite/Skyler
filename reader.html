<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Skyler, I Wish to Breathe Another Season – PDF Viewer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<style>
  body {
    margin:0;
    font-family:'Roboto Slab', serif;
    background:#0d2a3a;
    color:#fff;
    display:flex;
    flex-direction:column;
    height:100vh;
    overflow:hidden;
  }

  .toolbar {
    display:flex;
    align-items:center;
    gap:10px;
    background:#082133;
    padding:8px 16px;
    position:sticky;
    top:0;
    z-index:10;
    flex-shrink:0;
  }

  .toolbar button,
  .toolbar input {
    background-color:#eee;
    border:none;
    padding:6px 10px;
    border-radius:4px;
    cursor:pointer;
    color:#0d2a3a;
    font-weight:600;
  }

  #pdf-container-wrapper {
    flex:1;
    overflow-y:auto;
    position:relative;
  }

  #pdf-container {
    padding:18px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    transform-origin:top center;
  }

  canvas {
    box-shadow:0 0 8px rgba(0,0,0,0.5);
    border-radius:4px;
    display:block;
  }
</style>
</head>
<body>

<div class="toolbar">
  <button id="closeBtn">Close</button>

  <button id="zoomOut">−</button>
  <span>Zoom</span>
  <button id="zoomIn">+</button>

  <span>Page:</span>
  <input type="number" id="pageNumber" value="1" min="1">
  <span id="pageCount">/ ?</span>
</div>

<div id="pdf-container-wrapper">
  <div id="pdf-container"></div>
</div>

<script>
  const urlParams = new URLSearchParams(window.location.search);
  const pdfUrl = urlParams.get("file");
  if (!pdfUrl) { alert("PDF file not specified!"); throw new Error("No PDF file provided"); }

  const pdfWrapper = document.getElementById("pdf-container-wrapper");
  const pdfContainer = document.getElementById("pdf-container");
  const pageNumInput = document.getElementById("pageNumber");
  const pageCountSpan = document.getElementById("pageCount");

  let pdfDoc = null;
  let canvases = []; // {canvas, pageNum, renderedScale}
  let cssZoom = 1;   // fast UI zoom (CSS transform)
  let renderQuality = 1; // multiplier for actual render (backing scale)
  const RENDER_BUFFER_PX = 1000; // how far above/below viewport to pre-render

  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

  pdfjsLib.getDocument(pdfUrl).promise.then((pdf) => {
    pdfDoc = pdf;
    pageCountSpan.textContent = "/ " + pdf.numPages;
    createPlaceholders();
    // initial render pass
    updateVisiblePages();
  }).catch(err => {
    alert("Failed to load PDF: " + err.message);
    console.error(err);
  });

  // create placeholder canvases (so layout exists immediately)
  function createPlaceholders() {
    pdfContainer.innerHTML = "";
    canvases = [];
    for (let i = 1; i <= pdfDoc.numPages; i++) {
      const canvas = document.createElement("canvas");
      canvas.dataset.pagenum = i;
      canvas.style.display = "block";
      // temporary size: we'll size for the actual PDF page when first render happens.
      canvas.style.width = "600px"; // temporary fallback until real size known
      canvas.style.height = "800px";
      pdfContainer.appendChild(canvas);
      canvases.push({ canvas, pageNum: i, renderedScale: 0, viewportWidth: null, viewportHeight: null, pageRef: null });
    }
  }

  // compute the backing scale we need for crisp text:
  function computeBackingScale() {
    // devicePixelRatio and current CSS zoom both contribute.
    // If user wants very crisp text, add a small multiplier (1.0 ~ normal, 1.3 sharper)
    const dpr = window.devicePixelRatio || 1;
    // renderQuality is the multiplier for high-quality re-render; can be tuned
    return Math.max(1, dpr) * renderQuality * cssZoom;
  }

  // Render a single page at the specified backingScale (accurate pixel size)
  async function renderPage(pageIndex, backingScale) {
    const target = canvases[pageIndex];
    if (!target) return;
    const canvas = target.canvas;

    // get page (cache pageRef so we don't call getPage repeatedly)
    if (!target.pageRef) target.pageRef = await pdfDoc.getPage(target.pageNum);
    const page = target.pageRef;

    // get viewport at scale=1 (PDF units -> CSS points)
    const baseViewport = page.getViewport({ scale: 1 });

    // compute CSS size (width/height in CSS pixels at scale 1)
    const cssWidth = Math.round(baseViewport.width);
    const cssHeight = Math.round(baseViewport.height);

    // backing pixel size
    const backingW = Math.ceil(cssWidth * backingScale);
    const backingH = Math.ceil(cssHeight * backingScale);

    // Avoid re-render if already rendered at equal or higher backingScale
    if (target.renderedScale >= backingScale && target.viewportWidth === cssWidth && target.viewportHeight === cssHeight) {
      return; // already good enough
    }

    // set canvas backing size for crisp text
    canvas.width = backingW;
    canvas.height = backingH;

    // set CSS display size (how big it looks on screen)
    canvas.style.width = cssWidth + "px";
    canvas.style.height = cssHeight + "px";

    const ctx = canvas.getContext("2d", { alpha: false });
    // disable smoothing for sharper text (optional)
    ctx.imageSmoothingEnabled = false;

    // set transform so PDF draws correctly into backing pixels
    ctx.setTransform(backingScale, 0, 0, backingScale, 0, 0);

    // Render with viewport scaled so drawing commands are in CSS pts then scaled by transform
    const renderViewport = page.getViewport({ scale: 1 }); // draw at scale 1 then backing via transform
    const renderTask = page.render({ canvasContext: ctx, viewport: renderViewport });

    try {
      await renderTask.promise;
      target.renderedScale = backingScale;
      target.viewportWidth = cssWidth;
      target.viewportHeight = cssHeight;
    } catch (err) {
      console.error("Render failed for page", target.pageNum, err);
    }
  }

  // Determine visible pages and update page number. Also ensure visible pages are rendered at proper backing scale.
  let rafPending = false;
  function updateVisiblePages() {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(async () => {
      rafPending = false;
      const wrapperRect = pdfWrapper.getBoundingClientRect();
      const centerY = wrapperRect.top + wrapperRect.height / 2;

      // find canvas whose rect contains the vertical center (best for page detection)
      let activeIndex = null;
      for (let i = 0; i < canvases.length; i++) {
        const rect = canvases[i].canvas.getBoundingClientRect();
        if (rect.top <= centerY && rect.bottom >= centerY) {
          activeIndex = i;
          break;
        }
      }
      // fallback: if none contains center, pick the closest by distance to center
      if (activeIndex === null) {
        let bestDist = Infinity;
        for (let i = 0; i < canvases.length; i++) {
          const rect = canvases[i].canvas.getBoundingClientRect();
          const dist = Math.min(Math.abs(rect.top - centerY), Math.abs(rect.bottom - centerY));
          if (dist < bestDist) { bestDist = dist; activeIndex = i; }
        }
      }
      if (activeIndex !== null) {
        pageNumInput.value = canvases[activeIndex].pageNum;
      }

      // Now render visible pages + buffer
      const backingScale = computeBackingScale();
      const topRender = wrapperRect.top - RENDER_BUFFER_PX;
      const bottomRender = wrapperRect.bottom + RENDER_BUFFER_PX;

      // render pages whose rect intersects [topRender, bottomRender]
      const renderPromises = [];
      for (let i = 0; i < canvases.length; i++) {
        const rect = canvases[i].canvas.getBoundingClientRect();
        if ((rect.bottom >= topRender && rect.top <= bottomRender) || canvases[i].renderedScale === 0) {
          // render if in range or never rendered yet
          renderPromises.push(renderPage(i, backingScale));
        }
      }
      await Promise.all(renderPromises);
    });
  }

  // debounce scroll & resize
  let scrollTimer = null;
  pdfWrapper.addEventListener("scroll", () => {
    // cheap update: change page number immediately based on center but defer heavy rendering
    updateVisiblePages();
    if (scrollTimer) clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => { updateVisiblePages(); }, 120);
  }, { passive: true });

  window.addEventListener("resize", () => {
    // on resize, we should re-render visible pages at new backingScale
    updateVisiblePages();
  });

  // Manual jump to page (smooth scroll)
  pageNumInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const p = Number(pageNumInput.value);
      if (p >= 1 && p <= pdfDoc.numPages) {
        const targetCanvas = canvases[p - 1].canvas;
        targetCanvas.scrollIntoView({ behavior: "smooth", block: "start" });
        // ensure it will be rendered after scrolling
        setTimeout(updateVisiblePages, 200);
      }
    }
  });

  // Fast CSS zoom (visual). We will re-render visible pages at new backingScale for crispness.
  document.getElementById("zoomIn").onclick = () => {
    cssZoom = Math.min(2.5, +(cssZoom + 0.1).toFixed(2));
    pdfContainer.style.transform = `scale(${cssZoom})`;
    pdfContainer.style.transformOrigin = "top center";
    // re-render visible pages at higher backing scale for crisp text
    // set renderQuality to 1 here; you can increase for extra sharpness
    renderQuality = 1;
    // schedule re-render after layout settles
    setTimeout(updateVisiblePages, 120);
  };

  document.getElementById("zoomOut").onclick = () => {
    cssZoom = Math.max(0.4, +(cssZoom - 0.1).toFixed(2));
    pdfContainer.style.transform = `scale(${cssZoom})`;
    pdfContainer.style.transformOrigin = "top center";
    setTimeout(updateVisiblePages, 120);
  };

  // Close button
  document.getElementById("closeBtn").onclick = () => { window.close(); };

  // initial call in case user doesn't interact
  // small delay so canvases exist
  setTimeout(updateVisiblePages, 150);
</script>


</body>
</html>
